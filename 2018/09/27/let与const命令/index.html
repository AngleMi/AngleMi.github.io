<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="1、块级作用域  为什么需要块级作用域？  ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，==内层变量可能覆盖外层变量==： 12345678var tmp = new Date();function f() &amp;#123;    console.log(tmp);    if(false) &amp;#123;        var tmp = &amp;apos;hel">
<meta property="og:type" content="article">
<meta property="og:title" content="let与const命令">
<meta property="og:url" content="http://yoursite.com/2018/09/27/let与const命令/index.html">
<meta property="og:site_name" content="SunShine">
<meta property="og:description" content="1、块级作用域  为什么需要块级作用域？  ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，==内层变量可能覆盖外层变量==： 12345678var tmp = new Date();function f() &amp;#123;    console.log(tmp);    if(false) &amp;#123;        var tmp = &amp;apos;hel">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/09/27/let与const命令/6A6EFFE6B3924E19B9600CD45BCB1CCA">
<meta property="og:image" content="http://yoursite.com/2018/09/27/let与const命令/F5A9DD5CBF274808B0A5BEA66E7D7B1D">
<meta property="og:image" content="http://yoursite.com/2018/09/27/let与const命令/EEDBC23147C34A8490B0BBADEE15BF2D">
<meta property="og:image" content="http://yoursite.com/2018/09/27/let与const命令/66957020CE014685B1199339E081249C">
<meta property="og:image" content="http://yoursite.com/2018/09/27/let与const命令/5071F1D05C544D07A01F736399E2E741">
<meta property="og:image" content="http://yoursite.com/2018/09/27/let与const命令/2A68EAFF42724967A857FFFAE8282B73">
<meta property="og:updated_time" content="2018-09-27T07:15:05.826Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="let与const命令">
<meta name="twitter:description" content="1、块级作用域  为什么需要块级作用域？  ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，==内层变量可能覆盖外层变量==： 12345678var tmp = new Date();function f() &amp;#123;    console.log(tmp);    if(false) &amp;#123;        var tmp = &amp;apos;hel">
<meta name="twitter:image" content="http://yoursite.com/2018/09/27/let与const命令/6A6EFFE6B3924E19B9600CD45BCB1CCA">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/09/27/let与const命令/"/>





  <title>let与const命令 | SunShine</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	<a href="https://github.com/AngleMi"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SunShine</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/27/let与const命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Min Zhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunShine">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">let与const命令</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-27T14:30:01+08:00">
                2018-09-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/《实战ES2015笔记》/" itemprop="url" rel="index">
                    <span itemprop="name">《实战ES2015笔记》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>1、块级作用域</p>
<ul>
<li>为什么需要块级作用域？</li>
</ul>
<p>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<p>第一种场景，==内层变量可能覆盖外层变量==：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line">function f() &#123;</span><br><span class="line">    console.log(tmp);</span><br><span class="line">    if(false) &#123;</span><br><span class="line">        var tmp = &apos;hell0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(); //undefined</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数f执行后，输出结果为undefined,原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p>
<p>第二种场景，==用来计数的循环变量泄露为全局变量==：</p>
<p>常见的坑——循环绑定事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">   &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var list = document.getElementById(&apos;list&apos;);</span><br><span class="line">var li = list.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for(var i=0; i&lt;li.length; i++) &#123;</span><br><span class="line">    li[i].onclick = function() &#123;</span><br><span class="line">        console.log(i); // 3,3,3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<p>第一种：立即调用的函数表达(IIFE)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var list = document.getElementById(&apos;list&apos;);</span><br><span class="line">var li = list.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for(var i=0; i&lt;li.length; i++) &#123;</span><br><span class="line">    (function(i)&#123;</span><br><span class="line">        li[i].onclick = function() &#123;</span><br><span class="line">            console.log(i); // 0, 1, 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种：将变量i保存给每个段落对象li上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var list = document.getElementById(&apos;list&apos;);</span><br><span class="line">var li = list.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for(var i=0; i&lt;li.length; i++) &#123;</span><br><span class="line">    li[i].i = i;</span><br><span class="line">    li[i].onclick = function() &#123;</span><br><span class="line">        console.log(this.i); // 0, 1, 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种：将变量i保存在匿名函数自身</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var list = document.getElementById(&apos;list&apos;);</span><br><span class="line">var li = list.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for(var i=0; i&lt;li.length; i++) &#123;</span><br><span class="line">   (li[i].onclick = function()&#123;</span><br><span class="line">       console.log(arguments.callee.i); // 0, 1, 2</span><br><span class="line">   &#125;).i = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四种：ES6新语法let关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var list = document.getElementById(&apos;list&apos;);</span><br><span class="line">var li = list.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for(let i=0; i&lt;li.length; i++) &#123;</span><br><span class="line">   li[i].onclick = function()&#123;</span><br><span class="line">       console.log(i); // 0, 1, 2</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ES6块级作用域</li>
</ul>
<p>==let==实际上为javaScript新增了块级作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">    let n=5;</span><br><span class="line">    if(true) &#123;</span><br><span class="line">        let n=10;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(n); //5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6允许块级作用域的任意嵌套。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123; let instance = &apos;hello world&apos; &#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。</p>
<p>内层作用域可以定义外层作用域的同名变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;</span><br><span class="line">    let instance = &apos;hello world&apos;;</span><br><span class="line">    &#123;let instance = &apos;hello world&apos;&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>++块级作用域的出现，实际上使获得广泛应用的立即执行函数表达式(IIFE)不再必要了。++</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// IIFE写法</span><br><span class="line">(function()&#123;</span><br><span class="line">    var tmp = ...;</span><br><span class="line">    ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// 块级作用域写法</span><br><span class="line">&#123;</span><br><span class="line">    let tmp = ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、let与var的区别与联系<br>对比| let | var<br>—|—|—<br>定义变量 | Y| Y<br>可被释放 | Y| Y<br>可被提升 | N| Y<br>重复定义检查 | Y| N<br>可被用于块状作用域 | Y| N<br>3、const的本质</p>
<p>const 实际上保证的，并不是变量的值不得改动，而是==变量指向的那个内存地址所保存的数据不得改动==。</p>
<p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。</p>
<p>但对于复杂数据类型的数据（主要是对象和数组），变量指向的内存地址，保存的知识一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址）,至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">//为foo添加一个属性，可以成功</span><br><span class="line">foo.prop = 123;</span><br><span class="line">console.log(foo.prop); //123</span><br><span class="line"></span><br><span class="line">//将foo指向另一个对象，就会报错</span><br><span class="line">foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only</span><br></pre></td></tr></table></figure>
<p>上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo执行指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<p>下面是另一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [];</span><br><span class="line">a.push(&apos;Hello&apos;); // 可执行</span><br><span class="line">a.length = 0; // 可执行</span><br><span class="line">a = [&apos;zhimin&apos;]; //报错</span><br></pre></td></tr></table></figure>
<p>上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a,就会报错。</p>
<p>==如果冻结一个对象？？？？？==</p>
<p>如果想将对象冻结，应该使用==Object.freeze==()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const foo = Object.freeze(&#123;&#125;);</span><br><span class="line">foo.prop = 123;</span><br><span class="line">console.log(foo); // &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>除了将对象本身冻结，对应的属性也应该冻结，下面是一个将对象彻底冻结的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 第一种深冻结函数</span><br><span class="line">let constantize = (obj) =&gt; &#123;</span><br><span class="line">    Object.freeze(obj);</span><br><span class="line">    Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class="line">        if(typeof obj[key] === &apos;object&apos;) &#123;</span><br><span class="line">            constantize(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const person = &#123;zhimin:&#123;age:25&#125;&#125;;</span><br><span class="line">constantize(person);</span><br><span class="line">person.zhimin.sex = &apos;nv&apos;;</span><br><span class="line">console.log(person); // &#123; zhimin: &#123; age: 25 &#125; &#125;</span><br><span class="line"></span><br><span class="line">//第二种深冻结函数</span><br><span class="line">Object.deepFreeze = function(obj) &#123;</span><br><span class="line">    var propNames = Object.getOwnPropertyNames(obj);</span><br><span class="line">    propNames.forEach(function(name) &#123;</span><br><span class="line">        var prop = obj[name];</span><br><span class="line">        if(typeof prop === &apos;object&apos; &amp;&amp;prop !== null) &#123;</span><br><span class="line">            Object.deepFreeze(prop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return Object.freeze(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj3 = Object.deepFreeze(&#123;a:&#123;b:1&#125;&#125;);</span><br><span class="line">obj3.a.c = 2;</span><br><span class="line">console.log(obj3);  // &#123; a: &#123; b: 1 &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>4、for..in, Object.keys()和Object.getOwnPropertyNames()的区别</p>
<p><strong>扩充：如何理解Object.create()???</strong></p>
<p>定义(MDN)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.create(proto, [propertiesObject])</span><br></pre></td></tr></table></figure>
<ul>
<li>proto：新创建对象的原型对象</li>
<li>propertiesObject:可选。要添加到新对象的可枚举（新添加的属性是其自身的属性，而不是其原型链上的属性）的属性。这些属性对应==Object.defineProperties==()的第二个参数。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">    isSportsCar: false,</span><br><span class="line">    introduction: function() &#123;</span><br><span class="line">        console.log(`Hi girl, this is a $&#123;this.name&#125;.</span><br><span class="line">        Do you like to have a drink with me? $&#123;this.isSportsCar&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const porsche = Object.create(car,&#123;</span><br><span class="line">    // color成为porsche的数据属性</span><br><span class="line">    color: &#123;</span><br><span class="line">        writable: true,</span><br><span class="line">        configurable:true,</span><br><span class="line">        value: &apos;yellow&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    // type成为porsche的访问器属性</span><br><span class="line">    type: &#123;</span><br><span class="line">        // writable、configurable等属性，不显示设置则默认为false</span><br><span class="line">        get:function()&#123;return &apos;convertible&apos;&#125;,</span><br><span class="line">        set:function(val)&#123;&quot;change this car to&quot;, val&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">porsche.name = &apos;Porsche 911&apos;; //name是porsche的属性，而不是car的</span><br><span class="line">porsche.isSportsCar = true;  // 继承的属性可以被复写</span><br><span class="line"></span><br><span class="line">porsche.introduction(); // Hi girl, this is a Porsche 911. Do you like to have a drink with me ? true</span><br></pre></td></tr></table></figure>
<p>在控制台中打印porsche如下：</p>
<p><img src="6A6EFFE6B3924E19B9600CD45BCB1CCA" alt="image"></p>
<p>Object.create()的模拟实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function createObj(obj) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    var F.prototype = obj;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Object.create()与{}的区别</p>
<ul>
<li>使用{}创建的对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;a:1&#125;;</span><br><span class="line">console.log(obj1);</span><br></pre></td></tr></table></figure>
<p>在chrome控制台打印如下：</p>
<p><img src="F5A9DD5CBF274808B0A5BEA66E7D7B1D" alt="image"></p>
<p>从上图可以看到，新创建的对象继承了Object自身的方法，如hasOwnProperty、toString等，在新对象上可以直接使用。</p>
<ul>
<li>使用Object.create()创建对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj2 = Object.create(null, &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        writable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        value: &apos;1&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(obj2);</span><br></pre></td></tr></table></figure>
<p>在chrome控制台打印如下：</p>
<p><img src="EEDBC23147C34A8490B0BBADEE15BF2D" alt="image"></p>
<p>可以看到，新创建的对象除了自身属性a之外，原型链上没有任何属性，也就是没有继承Object的任何东西，此时如果我们调用obj2.toString()会报Uncaught TypeError的错误</p>
<p>我们可以会注意到，第一个参数使用了null。也就是说将null设置成了新创建对象的原型，自然就不会又原型链上的属性。我们再把上面的例子改一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj3 = Object.create(&#123;&#125;, &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        writable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        value: &apos;1&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(obj3)</span><br></pre></td></tr></table></figure>
<p>将null改为{},结果是怎样的？ 在chrome控制台打印如下：</p>
<p><img src="66957020CE014685B1199339E081249C" alt="image"></p>
<p>可以看到，这样创建的对象和使用{}创建对象已经很相近了，但是还是有一点区别：==多了一层proto嵌套。==</p>
<p>最后再来改一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj4 = Object.create(Object.prototype, &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        writable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        value: &apos;1&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(obj4);</span><br></pre></td></tr></table></figure>
<p>chrome控制台打印如下：</p>
<p><img src="5071F1D05C544D07A01F736399E2E741" alt="image"></p>
<p>这次就和使用{}创建的对象一摸一样了。</p>
<p><strong>Object.create(null)的使用场景</strong></p>
<p>为什么很多源码中作者会使用Object.create(null)来初始化一个对象？这是作者的习惯，还是一个最佳实践？</p>
<p>其实都不是，这并不是作者不经思考随便用的，也不是js编程中的最佳事件，而是需要因地制宜，具体问题具体分析。</p>
<p>我们进一步比较一下Object.create(null)和{}创建空对象的区别：</p>
<p>在chrome打印如下：<br><img src="2A68EAFF42724967A857FFFAE8282B73" alt="image"></p>
<p>从上图可以看到，使用create创建的对象，没有任何属性，显示No properties,我们可以把它当作一个非常纯净的map来使用，我么可以自己定义hasOwnProperty、toString方法，不管是有意还是不小心，我们完全不必担心会将原型链上的同名方法覆盖掉。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Demo1:</span><br><span class="line">var a= &#123;...省略很多属性和方法...&#125;;</span><br><span class="line"></span><br><span class="line">//如果想要检查a是否存在一个名为toString的属性，你必须像下面这样进行检查：</span><br><span class="line">if(Object.prototype.hasOwnProperty.call(a,&apos;toString&apos;))&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">//为什么不能直接用a.hasOwnProperty(&apos;toString&apos;)?因为你可能给a添加了一个自定义的hasOwnProperty</span><br><span class="line">//你无法使用下面这种方式来进行判断,因为原型上的toString方法是存在的：</span><br><span class="line">if(a.toString)&#123;&#125;</span><br><span class="line"></span><br><span class="line">//Demo2:</span><br><span class="line">var a=Object.create(null)</span><br><span class="line">//你可以直接使用下面这种方式判断，因为存在的属性，都将定义在a上面，除非手动指定原型：</span><br><span class="line">if(a.toString)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>另一个使用create(null)的理由是，在我们使用for..in循环的时候会遍历对象原型链上的属性，使用create(null)就不必再对属性进行检查了，当然，我们也可以直接使用Object.keys()。</p>
<p>总结：</p>
<ol>
<li>你需要一个非常干净且高度可定制的对象当作数据字典的时候；</li>
<li>想节省hasOwnProperty带来的一丢丢性能损失并且可以偷懒少一点代码的时候<br>用Object.create(null)吧，其他时，用{}。</li>
</ol>
<p>言归正传，==看一下for..in、Object.keys()和Object.getOwnPropertyNames的区别==</p>
<p>首先我们需要一个父对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var parent = Object.create(Object.prototype, &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        value:1,</span><br><span class="line">        writable:true,</span><br><span class="line">        enumerable:true,</span><br><span class="line">        configurable:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>parent继承自Object.pototype，有一个可枚举的属性a。下面我们再创建一个继承自parent得对象child。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var child = Object.create(parent,&#123;</span><br><span class="line">    b:&#123;</span><br><span class="line">        value:2,</span><br><span class="line">        writable: true,</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable:true,</span><br><span class="line">    &#125;,</span><br><span class="line">    c:&#123;</span><br><span class="line">        value:3,</span><br><span class="line">        writable:true,</span><br><span class="line">        enumerable:false,</span><br><span class="line">        configurable:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>child有两个属性b和c,其中b为可枚举属性，c为不可枚举属性。</p>
<p>下面将用不同的方法遍历child对象：</p>
<ul>
<li>for..in</li>
</ul>
<p>for in 是最早来遍历对象的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var key in child) &#123;</span><br><span class="line">    console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// &gt; b</span><br><span class="line">// &gt; a</span><br></pre></td></tr></table></figure>
<p>从输出上可以看出，for in会==输出自身以及原型链上可枚举的属性==。</p>
<p>PS: 不同的浏览器对for in属性输出的顺序可能不同。</p>
<p>如果仅想输出自身的属性可以借助hasOwnProperty，可以过滤掉原型链上的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var key in child)&#123;</span><br><span class="line">    if(child.hasOwnProperty(key))&#123;</span><br><span class="line">        console.log(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &gt; b</span><br></pre></td></tr></table></figure>
<p>上面代码，仅输出了child自己的可枚举属性b,而没有输出原型parent中的属性。</p>
<ul>
<li>Object.keys()</li>
</ul>
<p>Object.keys是es6中新增的方法，用来获取对象自身的全部属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.keys(child));</span><br><span class="line"></span><br><span class="line">// &gt; [&quot;b&quot;]</span><br></pre></td></tr></table></figure>
<p>==可以看出Object.keys的效果和for in + hasOwnProperty的效果是一样的。==</p>
<ul>
<li>Object.getOwnPropertyNames()</li>
</ul>
<p>Object.getOwnPropertyNames也是ES6中新增的方法，用来获取对象自身的全部属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getOwnPropertyNames(child));</span><br><span class="line"></span><br><span class="line">// &gt; [&quot;b&quot;, &quot;c&quot;];</span><br></pre></td></tr></table></figure>
<p>从输出可以看出其和Object.keys()的区别。</p>
<p>5、变量的生命周期</p>
<p>在ECMAScript中，一个变量(或常量)的生命周期模式是固定的，有两种因素决定，分别是==作用域和对其的引用==。</p>
<p>在ECMAScript中，变量(或常量)的生命周期是从程序进入定义语句所在的作用域开始的，即便是在定义语句之前。</p>
<ol>
<li>ECMAScript引擎在进入一个作用域时，会先扫描这个作用域内的变量(或常量)定义语句(var,let或const)，然后在这个作用域内为扫描得到的变量名做准备，在当前作用域中被扫描到的变量名都会进入==未声明阶段==。</li>
<li>进入声明语句时，var foo, 即前半句是声明部分，用于在ECMAScript引擎中产生一个变量名，但此时该变量名没有对应的绑定和内存空间，所以“值”为undefined。</li>
<li>=的作用是作为变量的赋值语句，引擎执行至此处几位改变量的==赋值部分==，计算将要赋予变量名的值的物理长度(内存空间占用大小)，向系统申请相应大小的内存空间，然后将数据存储到里面去，并在变量名和内存空间之间建立==绑定关系==，此时变量(或常量)才得到了相应的值。</li>
<li>到当前作用域中的语句被执行完毕时，引擎便会检查该作用域中被定义的变量(或常量)的被引用情况，如果引用已被全部解除，引擎别拿回认为其应该被清除。</li>
<li>运行引擎会不断检查存在于运行时中的变量(或常量)的被引用情况，并重复第四步，直至程序结束。</li>
</ol>
<p>需要注意的时，在ES6标准之前，我们可能会遇到下面这种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;</span><br><span class="line">(function()&#123;</span><br><span class="line">  console.log(foo); // =&gt; undefined</span><br><span class="line">  var foo = 2;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>就如上面所说的，一旦引擎进入一个作用域时，会先扫描该作用域内的定义语句。在这段代码中，我们可以看到在外层作用域中定义了变量foo,而在内层的作用域中，我们在对变量foo读取代码后又对其再次“定义”。此时我们便可以发现在第二次定义语句之前对foo的引用所获得的值竟然时undefined，因为此时变量foo处于未声明阶段，即使它在上一层作用域已被定义。</p>
<p>但实际上，这并不符合正常的编程逻辑，所以在ES6的let和const中，引擎将这种行为视为错误行为，并抛出错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo); // =&gt; ReferenceError</span><br><span class="line">console.log(bar); // =&gt; ReferenceError</span><br><span class="line"></span><br><span class="line">let foo = 1;</span><br><span class="line">const bar = 2;</span><br></pre></td></tr></table></figure>
<p>ES2015标准中(一般情况下为严格模式)不允许变量(或常量)在被定义之前被其他语句所读取，以避免出现逻辑性错误。</p>
<p>总结：</p>
<p>从工程化角度上看，我们应该在ES2015中遵从一下三条原则：</p>
<ol>
<li>一般情况下，使用const来定义值的存储容器(常量)。</li>
<li>只有在值容器明确地被确定将会被改变时才使用let来定义(变量)。</li>
<li>不再使用var。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/27/箭头函数/" rel="prev" title="箭头函数">
                箭头函数 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/blog.jpg"
                alt="Min Zhi" />
            
              <p class="site-author-name" itemprop="name">Min Zhi</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Min Zhi</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>
